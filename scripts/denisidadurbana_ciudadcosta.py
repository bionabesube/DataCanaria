# -*- coding: utf-8 -*-
"""denisidadurbana-ciudadcosta.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YcZelZGI3Cae3X751Nl0LeSXhyfvOzsH
"""

import rasterio
from rasterio.plot import show
from rasterio.mask import mask
import geopandas as gpd
from shapely.geometry import box, mapping
import matplotlib.pyplot as plt
import requests
import os

## 1. Definir bounding box aproximada de Ciudad de la Costa
# Coordenadas: oeste, sur, este, norte
bbox = [-56.05, -34.9, -55.9, -34.75]
roi = box(*bbox)

# 2. Descargar un dataset de WorldPop (ejemplo: población 2000 a 2020 cada 5 años, Uruguay, 100m)

url = ["https://data.worldpop.org/GIS/Population/Global_2000_2020/2000/URY/ury_ppp_2000.tif", "https://data.worldpop.org/GIS/Population/Global_2000_2020/2005/URY/ury_ppp_2005.tif", "https://data.worldpop.org/GIS/Population/Global_2000_2020/2010/URY/ury_ppp_2010.tif", "https://data.worldpop.org/GIS/Population/Global_2000_2020/2015/URY/ury_ppp_2015.tif", "https://data.worldpop.org/GIS/Population/Global_2000_2020/2020/URY/ury_ppp_2020.tif"]
tif_path = ["data/raw/worldpop_ury_2000.tif", "data/raw/worldpop_ury_2005.tif", "data/raw/worldpop_ury_2010.tif", "data/raw/worldpop_ury_2015.tif", "data/raw/worldpop_ury_2020.tif"]
r = []

i = 0
for i in range(len(tif_path)):
  if not os.path.exists(tif_path[i]):
      print(f"Descargando raster: {url[i]}...")
      response = requests.get(url[i], stream=True)
      with open(tif_path[i], "wb") as f:
          for chunk in response.iter_content(chunk_size=8192):
              f.write(chunk)
      print(f"Descarga {i} completa.")

# 3. Recortar el raster a Ciudad de la Costa and 4. Mostrar densidad poblacional for each file
for i in range(len(tif_path)):
  try:
    with rasterio.open(tif_path[i]) as src:
        out_image, out_transform = mask(src, [mapping(roi)], crop=True)
        out_meta = src.meta.copy()
        out_meta.update({
            "height": out_image.shape[1],
            "width": out_image.shape[2],
            "transform": out_transform
        })

        # Asegurarse de usar nodata
        nodata = src.nodata
        if nodata is not None:
            out_image = out_image.astype(float)
            out_image[out_image == nodata] = 0  # o np.nan según lo que quieras

        # 4. Mostrar densidad poblacional
        fig, ax = plt.subplots(figsize=(8,6))
        img = show(out_image, transform=out_transform, cmap="viridis", ax=ax)
        plt.title(f"Population density - Ciudad de la Costa ({tif_path[i].split('_')[-1].split('.')[0]})")
        plt.colorbar(img.get_images()[0], label="Residents per pixel", ax=ax)
        plt.show()
  except Exception as e:
    print(f"Error processing file {tif_path[i]}: {e}")
    continue # Skip to the next file in case of an error

"""# Task
Allow the user to select two years from 2000, 2005, 2010, 2015, and 2020, then calculate and visualize the difference in population data between the corresponding TIFF files, masked by the `roi` region. Handle potential errors during the process.

## Select years for comparison

### Subtask:
Allow the user to input the two years they want to compare (from 2000, 2005, 2010, 2015, and 2020).

**Reasoning**:
Define the list of available years and prompt the user for the first year, then validate the input.
"""

available_years = [2000, 2005, 2010, 2015, 2020]

try:
    year1 = int(input(f"Enter the first year from the list {available_years}: "))
    if year1 not in available_years:
        print("Error: Invalid year entered for the first year.")
        raise ValueError("Invalid year")
except ValueError:
    year1 = None # Indicate an error occurred

"""**Reasoning**:
Prompt the user for the second year and validate the input, ensuring it is different from the first year and within the available years.


"""

if year1 is not None:
    try:
        year2 = int(input(f"Enter the second year from the list {available_years} (must be different from {year1}): "))
        if year2 not in available_years or year2 == year1:
            print("Error: Invalid year entered for the second year or it is the same as the first year.")
            raise ValueError("Invalid year")
    except ValueError:
        year2 = None # Indicate an error occurred
else:
    year2 = None # Cannot proceed if year1 was invalid

"""## Load selected tiff files

### Subtask:
Load the two TIFF files corresponding to the selected years using `rasterio`.

**Reasoning**:
Create a dictionary mapping years to filenames and load the two selected TIFF files using rasterio.
"""

# 1. Create a dictionary mapping years to their respective filenames
tif_files = {
    2000: "data/raw/worldpop_ury_2000.tif",
    2005: "data/raw/worldpop_ury_2005.tif",
    2010: "data/raw/worldpop_ury_2010.tif",
    2015: "data/raw/worldpop_ury_2015.tif",
    2020: "data/raw/worldpop_ury_2020.tif"
}

# 2. Use the selected year1 and year2 to get the corresponding filenames
filename1 = tif_files.get(year1)
filename2 = tif_files.get(year2)

# 3. Open the TIFF file for year1 and store it in src1
src1 = rasterio.open(filename1)

# 4. Open the TIFF file for year2 and store it in src2
src2 = rasterio.open(filename2)

"""## Mask the rasters

### Subtask:
Apply the previously defined `roi` (region of interest) mask to both loaded rasters to focus on the area of Ciudad de la Costa.

**Reasoning**:
Apply the mask to both rasters and handle nodata values.
"""

from rasterio.mask import mask
import numpy as np

# Apply mask to the first raster
out_image1, out_transform1 = mask(src1, [mapping(roi)], crop=True)

# Apply mask to the second raster
out_image2, out_transform2 = mask(src2, [mapping(roi)], crop=True)

# Handle nodata values for the first raster
nodata1 = src1.nodata
if nodata1 is not None:
    out_image1 = out_image1.astype(float)
    out_image1[out_image1 == nodata1] = 0  # Replace with 0

# Handle nodata values for the second raster
nodata2 = src2.nodata
if nodata2 is not None:
    out_image2 = out_image2.astype(float)
    out_image2[out_image2 == nodata2] = 0  # Replace with 0

"""## Calculate the difference

### Subtask:
Subtract the population data of the earlier year from the later year to get the population change.

**Reasoning**:
Determine the earlier and later years and subtract the corresponding masked images to find the population difference.
"""

# Determine which year is earlier and which is later
if year1 < year2:
    earlier_year = year1
    later_year = year2
    earlier_image = out_image1
    later_image = out_image2
else:
    earlier_year = year2
    later_year = year1
    earlier_image = out_image2
    later_image = out_image1

# Subtract the population data of the earlier year from the later year
population_difference = later_image - earlier_image

"""## Visualize the difference

### Subtask:
Create a plot showing the spatial distribution of the population difference.

**Reasoning**:
Generate the code to create a plot showing the spatial distribution of the population difference using matplotlib and rasterio.plot.show.
"""

# Create a figure and axes for the plot
fig, ax = plt.subplots(figsize=(10, 8))

# Import TwoSlopeNorm
from matplotlib.colors import TwoSlopeNorm

# Display the population difference image with normalization centered at 0
# Using 'coolwarm' as it's a diverging colormap, and centering ensures 0 is the middle color (often white or gray)
norm = TwoSlopeNorm(vmin=population_difference.min(), vcenter=0, vmax=population_difference.max())
img = show(population_difference, transform=out_transform1, cmap="coolwarm", ax=ax, norm=norm)

# Add a title to the plot
plt.title(f"Population Change in Ciudad de la Costa ({earlier_year} - {later_year})")

# Add a colorbar
plt.colorbar(img.get_images()[0], label="Population Change per pixel")

# Display the plot
plt.show()

"""## Add context to the visualization

### Subtask:
Include a title, colorbar, and labels to make the plot understandable.

## Handle potential errors

### Subtask:
Include error handling for cases like invalid year input or issues during file processing.

**Reasoning**:
Review the existing code and add error handling for file loading, masking, and calculations.
"""

# Reviewing existing code and adding error handling.

# Error handling for selecting years is already in the previous steps.
# Proceeding with file loading with error handling.

src1 = None
src2 = None
filename1 = tif_files.get(year1)
filename2 = tif_files.get(year2)

if filename1 and filename2:
    try:
        src1 = rasterio.open(filename1)
        print(f"Successfully opened {filename1}")
    except rasterio.errors.RasterioIOError as e:
        print(f"Error opening file {filename1}: {e}")
    except Exception as e:
        print(f"An unexpected error occurred while opening {filename1}: {e}")

    try:
        src2 = rasterio.open(filename2)
        print(f"Successfully opened {filename2}")
    except rasterio.errors.RasterioIOError as e:
        print(f"Error opening file {filename2}: {e}")
    except Exception as e:
        print(f"An unexpected error occurred while opening {filename2}: {e}")

# Proceeding with masking and calculation with error handling, only if files were opened successfully.
out_image1 = None
out_image2 = None
out_transform1 = None
out_transform2 = None
population_difference = None

if src1 and src2:
    try:
        out_image1, out_transform1 = mask(src1, [mapping(roi)], crop=True)
        print(f"Successfully masked {filename1}")

        # Handle nodata values for the first raster
        nodata1 = src1.nodata
        if nodata1 is not None:
            out_image1 = out_image1.astype(float)
            out_image1[out_image1 == nodata1] = 0  # Replace with 0


    except Exception as e:
        print(f"Error masking file {filename1}: {e}")
        out_image1 = None # Set to None if masking fails


    try:
        out_image2, out_transform2 = mask(src2, [mapping(roi)], crop=True)
        print(f"Successfully masked {filename2}")

        # Handle nodata values for the second raster
        nodata2 = src2.nodata
        if nodata2 is not None:
            out_image2 = out_image2.astype(float)
            out_image2[out_image2 == nodata2] = 0  # Replace with 0

    except Exception as e:
        print(f"Error masking file {filename2}: {e}")
        out_image2 = None # Set to None if masking fails


    # Proceed with calculation only if both images were masked successfully and have compatible shapes
    if out_image1 is not None and out_image2 is not None and out_image1.shape == out_image2.shape:
        try:
            # Determine which year is earlier and which is later
            if year1 < year2:
                earlier_year = year1
                later_year = year2
                earlier_image = out_image1
                later_image = out_image2
            else:
                earlier_year = year2
                later_year = year1
                earlier_image = out_image2
                later_image = out_image1

            # Subtract the population data of the earlier year from the later year
            population_difference = later_image - earlier_image
            print("Successfully calculated population difference.")

        except Exception as e:
            print(f"Error calculating population difference: {e}")
            population_difference = None # Set to None if calculation fails
    elif out_image1 is not None and out_image2 is not None and out_image1.shape != out_image2.shape:
        print(f"Error: Masked images have different shapes: {out_image1.shape} vs {out_image2.shape}. Cannot calculate difference.")
        population_difference = None
else:
    print("File loading failed, skipping masking and calculation.")

# Visualization step would follow here, and should also check if population_difference is not None

import rasterio
from rasterio.plot import show
import matplotlib.pyplot as plt

# Define the path to the TIFF file
tif_file_path = 'GHS_BUILT_C_MSZ_E2018_GLOBE_R2023A_54009_10_V1_0_R14_C14.tif'

# Open the TIFF file
try:
    with rasterio.open(tif_file_path) as src:
        # Read the raster data (assuming it's a single band)
        raster_data = src.read(1)

        # Display the raster data
        fig, ax = plt.subplots(figsize=(10, 10))
        img = show(raster_data, transform=src.transform, ax=ax, cmap='gray') # Using grayscale for built-up area data

        # Add a title and colorbar
        plt.title("Built-up Area Density (GHS-BUILT-C)")
        plt.colorbar(img.get_images()[0], label="Density Value")

        # Show the plot
        plt.show()

except rasterio.errors.RasterioIOError as e:
    print(f"Error opening or reading the raster file: {e}")
except Exception as e:
    print(f"An unexpected error occurred: {e}")

import rasterio
from rasterio.mask import mask
from shapely.geometry import mapping
import numpy as np

# Define the tif_files dictionary again
tif_files = {
    2000: "data/raw/worldpop_ury_2000.tif",
    2005: "data/raw/worldpop_ury_2005.tif",
    2010: "data/raw/worldpop_ury_2010.tif",
    2015: "data/raw/worldpop_ury_2015.tif",
    2020: "data/raw/worldpop_ury_2020.tif"
}

# 1. Initialize an empty list called population_data to store the total population for each year.
population_data = []
# 2. Initialize an empty list called years to store the corresponding years.
years = []

# 3. Iterate through the tif_files dictionary which maps years to filenames.
for year, filename in tif_files.items():
    try:
        # 4. For each year and filename in the dictionary, open the TIFF file using rasterio.open().
        with rasterio.open(filename) as src:
            print(f"Processing {filename} for year {year}...")
            # 5. Mask the opened raster using the roi (region of interest) and mask() function. Ensure crop=True.
            out_image, out_transform = mask(src, [mapping(roi)], crop=True)

            # 6. Handle nodata values in the masked image. If src.nodata is not None, convert the masked image to float and replace nodata values with 0.
            nodata = src.nodata
            if nodata is not None:
                out_image = out_image.astype(float)
                out_image[out_image == nodata] = 0  # Replace with 0

            # 7. Calculate the sum of all pixel values in the masked image. This represents the total population for the masked area in that year.
            total_population = np.sum(out_image)

            # 8. Append the calculated total population to the population_data list.
            population_data.append(total_population)
            # 9. Append the current year to the years list.
            years.append(year)
            print(f"Finished processing {filename}. Total population: {total_population}")

    except rasterio.errors.RasterioIOError as e:
        print(f"Error opening or processing file {filename}: {e}")
        continue # Skip to the next file in case of an error
    except Exception as e:
        print(f"An unexpected error occurred while processing {filename}: {e}")
        continue # Skip to the next file in case of an error

# 10. Close the raster file using src.close(). (Handled by 'with' statement)

from shapely.geometry import box

# Define bounding box aproximada de Ciudad de la Costa
# Coordenadas: oeste, sur, este, norte
bbox = [-56.05, -34.9, -55.9, -34.75]
roi = box(*bbox)

# Define the tif_files dictionary again
tif_files = {
    2000: "data/raw/worldpop_ury_2000.tif",
    2005: "data/raw/worldpop_ury_2005.tif",
    2010: "data/raw/worldpop_ury_2010.tif",
    2015: "data/raw/worldpop_ury_2015.tif",
    2020: "data/raw/worldpop_ury_2020.tif"
}

# 1. Initialize an empty list called population_data to store the total population for each year.
population_data = []
# 2. Initialize an empty list called years to store the corresponding years.
years = []

# 3. Iterate through the tif_files dictionary which maps years to filenames.
for year, filename in tif_files.items():
    try:
        # 4. For each year and filename in the dictionary, open the TIFF file using rasterio.open().
        with rasterio.open(filename) as src:
            print(f"Processing {filename} for year {year}...")
            # 5. Mask the opened raster using the roi (region of interest) and mask() function. Ensure crop=True.
            out_image, out_transform = mask(src, [mapping(roi)], crop=True)

            # 6. Handle nodata values in the masked image. If src.nodata is not None, convert the masked image to float and replace nodata values with 0.
            nodata = src.nodata
            if nodata is not None:
                out_image = out_image.astype(float)
                out_image[out_image == nodata] = 0  # Replace with 0

            # 7. Calculate the sum of all pixel values in the masked image. This represents the total population for the masked area in that year.
            total_population = np.sum(out_image)

            # 8. Append the calculated total population to the population_data list.
            population_data.append(total_population)
            # 9. Append the current year to the years list.
            years.append(year)
            print(f"Finished processing {filename}. Total population: {total_population}")

    except rasterio.errors.RasterioIOError as e:
        print(f"Error opening or processing file {filename}: {e}")
        continue # Skip to the next file in case of an error
    except Exception as e:
        print(f"An unexpected error occurred while processing {filename}: {e}")
        continue # Skip to the next file in case of an error

# 10. Close the raster file using src.close(). (Handled by 'with' statement)

from sklearn.linear_model import LinearRegression
import numpy as np

# Reshape the years data to be a 2D array
years_reshaped = np.array(years).reshape(-1, 1)

# Instantiate a LinearRegression model
model = LinearRegression()

# Fit the linear regression model to the historical data
model.fit(years_reshaped, population_data)

# 1. Create a NumPy array named future_years containing the years for which you want to make predictions: 2025, 2030, 2035, 2040, 2045, and 2050.
future_years = np.array([2025, 2030, 2035, 2040, 2045, 2050])

# 2. Reshape the future_years array to be a 2D array using .reshape(-1, 1)
future_years_reshaped = future_years.reshape(-1, 1)

# 3. Use the trained model (the LinearRegression object) to predict the population for the future_years_reshaped.
predicted_population = model.predict(future_years_reshaped)

# 4. Print or display the future_years and their corresponding predicted_population values to verify the output.
for year, population in zip(future_years, predicted_population):
    print(f"Predicted population for {year}: {population:.2f}")

import matplotlib.pyplot as plt

# Create a figure and axes for the plot
fig, ax = plt.subplots(figsize=(10, 6))

# Plot the historical population data
ax.plot(years, population_data, marker='o', linestyle='-', label='Historical Population')

# Plot the predicted population data
ax.plot(future_years, predicted_population, marker='x', linestyle='--', color='red', label='Projected Population')

# Add a title to the plot
ax.set_title('Population Growth and Projection for Ciudad de la Costa')

# Add labels to the x-axis and y-axis
ax.set_xlabel('Year')
ax.set_ylabel('Population')

# Add a legend to the plot
ax.legend()

# Add a grid to the plot
ax.grid(True)

# Display the plot
plt.show()