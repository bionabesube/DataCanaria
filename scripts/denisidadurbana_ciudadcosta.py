# -*- coding: utf-8 -*-
"""denisidadurbana-ciudadcosta.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YcZelZGI3Cae3X751Nl0LeSXhyfvOzsH
"""


import rasterio
from rasterio.plot import show
from rasterio.mask import mask
import geopandas as gpd
from shapely.geometry import box, mapping
import matplotlib.pyplot as plt
import requests
import os

## 1. Definir bounding box aproximada de Ciudad de la Costa
# Coordenadas: oeste, sur, este, norte
bbox = [-56.05, -34.9, -55.9, -34.75]
roi = box(*bbox)

# 2. Descargar un dataset de WorldPop (ejemplo: población 2000 a 2020 cada 5 años, Uruguay, 100m)

url = ["https://data.worldpop.org/GIS/Population/Global_2000_2020/2000/URY/ury_ppp_2000.tif", "https://data.worldpop.org/GIS/Population/Global_2000_2020/2005/URY/ury_ppp_2005.tif", "https://data.worldpop.org/GIS/Population/Global_2000_2020/2010/URY/ury_ppp_2010.tif", "https://data.worldpop.org/GIS/Population/Global_2000_2020/2015/URY/ury_ppp_2015.tif", "https://data.worldpop.org/GIS/Population/Global_2000_2020/2020/URY/ury_ppp_2020.tif"]
tif_path = ["worldpop_ury_2000.tif", "worldpop_ury_2005.tif", "worldpop_ury_2010.tif", "worldpop_ury_2015.tif", "worldpop_ury_2020.tif"]
r = []

i = 0
for i in range(len(tif_path)):
  if not os.path.exists(tif_path[i]):
      print(f"Descargando raster: {url[i]}...")
      response = requests.get(url[i], stream=True)
      with open(tif_path[i], "wb") as f:
          for chunk in response.iter_content(chunk_size=8192):
              f.write(chunk)
      print(f"Descarga {i} completa.")

# 3. Recortar el raster a Ciudad de la Costa and 4. Mostrar densidad poblacional for each file
for i in range(len(tif_path)):
  try:
    with rasterio.open(tif_path[i]) as src:
        out_image, out_transform = mask(src, [mapping(roi)], crop=True)
        out_meta = src.meta.copy()
        out_meta.update({
            "height": out_image.shape[1],
            "width": out_image.shape[2],
            "transform": out_transform
        })

        # Asegurarse de usar nodata
        nodata = src.nodata
        if nodata is not None:
            out_image = out_image.astype(float)
            out_image[out_image == nodata] = 0  # o np.nan según lo que quieras

        # 4. Mostrar densidad poblacional
        fig, ax = plt.subplots(figsize=(8,6))
        img = show(out_image, transform=out_transform, cmap="viridis", ax=ax)
        plt.title(f"Densidad de población - Ciudad de la Costa ({tif_path[i].split('_')[-1].split('.')[0]})")
        plt.colorbar(img.get_images()[0], label="Habitantes por píxel", ax=ax)
        plt.show()
  except Exception as e:
    print(f"Error processing file {tif_path[i]}: {e}")
    continue # Skip to the next file in case of an error

"""# Task
Allow the user to select two years from 2000, 2005, 2010, 2015, and 2020, then calculate and visualize the difference in population data between the corresponding TIFF files, masked by the `roi` region. Handle potential errors during the process.

## Select years for comparison

### Subtask:
Allow the user to input the two years they want to compare (from 2000, 2005, 2010, 2015, and 2020).

**Reasoning**:
Define the list of available years and prompt the user for the first year, then validate the input.
"""

available_years = [2000, 2005, 2010, 2015, 2020]

try:
    year1 = int(input(f"Enter the first year from the list {available_years}: "))
    if year1 not in available_years:
        print("Error: Invalid year entered for the first year.")
        raise ValueError("Invalid year")
except ValueError:
    year1 = None # Indicate an error occurred

"""**Reasoning**:
Prompt the user for the second year and validate the input, ensuring it is different from the first year and within the available years.


"""

if year1 is not None:
    try:
        year2 = int(input(f"Enter the second year from the list {available_years} (must be different from {year1}): "))
        if year2 not in available_years or year2 == year1:
            print("Error: Invalid year entered for the second year or it is the same as the first year.")
            raise ValueError("Invalid year")
    except ValueError:
        year2 = None # Indicate an error occurred
else:
    year2 = None # Cannot proceed if year1 was invalid

"""## Load selected tiff files

### Subtask:
Load the two TIFF files corresponding to the selected years using `rasterio`.

**Reasoning**:
Create a dictionary mapping years to filenames and load the two selected TIFF files using rasterio.
"""

# 1. Create a dictionary mapping years to their respective filenames
tif_files = {
    2000: "worldpop_ury_2000.tif",
    2005: "worldpop_ury_2005.tif",
    2010: "worldpop_ury_2010.tif",
    2015: "worldpop_ury_2015.tif",
    2020: "worldpop_ury_2020.tif"
}

# 2. Use the selected year1 and year2 to get the corresponding filenames
filename1 = tif_files.get(year1)
filename2 = tif_files.get(year2)

# 3. Open the TIFF file for year1 and store it in src1
src1 = rasterio.open(filename1)

# 4. Open the TIFF file for year2 and store it in src2
src2 = rasterio.open(filename2)

"""## Mask the rasters

### Subtask:
Apply the previously defined `roi` (region of interest) mask to both loaded rasters to focus on the area of Ciudad de la Costa.

**Reasoning**:
Apply the mask to both rasters and handle nodata values.
"""

from rasterio.mask import mask
import numpy as np

# Apply mask to the first raster
out_image1, out_transform1 = mask(src1, [mapping(roi)], crop=True)

# Apply mask to the second raster
out_image2, out_transform2 = mask(src2, [mapping(roi)], crop=True)

# Handle nodata values for the first raster
nodata1 = src1.nodata
if nodata1 is not None:
    out_image1 = out_image1.astype(float)
    out_image1[out_image1 == nodata1] = 0  # Replace with 0

# Handle nodata values for the second raster
nodata2 = src2.nodata
if nodata2 is not None:
    out_image2 = out_image2.astype(float)
    out_image2[out_image2 == nodata2] = 0  # Replace with 0

"""## Calculate the difference

### Subtask:
Subtract the population data of the earlier year from the later year to get the population change.

**Reasoning**:
Determine the earlier and later years and subtract the corresponding masked images to find the population difference.
"""

# Determine which year is earlier and which is later
if year1 < year2:
    earlier_year = year1
    later_year = year2
    earlier_image = out_image1
    later_image = out_image2
else:
    earlier_year = year2
    later_year = year1
    earlier_image = out_image2
    later_image = out_image1

# Subtract the population data of the earlier year from the later year
population_difference = later_image - earlier_image

"""## Visualize the difference

### Subtask:
Create a plot showing the spatial distribution of the population difference.

**Reasoning**:
Generate the code to create a plot showing the spatial distribution of the population difference using matplotlib and rasterio.plot.show.
"""

# Create a figure and axes for the plot
fig, ax = plt.subplots(figsize=(10, 8))

# Import TwoSlopeNorm
from matplotlib.colors import TwoSlopeNorm

# Display the population difference image with normalization centered at 0
# Using 'coolwarm' as it's a diverging colormap, and centering ensures 0 is the middle color (often white or gray)
norm = TwoSlopeNorm(vmin=population_difference.min(), vcenter=0, vmax=population_difference.max())
img = show(population_difference, transform=out_transform1, cmap="coolwarm", ax=ax, norm=norm)

# Add a title to the plot
plt.title(f"Population Change in Ciudad de la Costa ({earlier_year} - {later_year})")

# Add a colorbar
plt.colorbar(img.get_images()[0], label="Population Change")

# Display the plot
plt.show()

"""## Add context to the visualization

### Subtask:
Include a title, colorbar, and labels to make the plot understandable.

## Handle potential errors

### Subtask:
Include error handling for cases like invalid year input or issues during file processing.

**Reasoning**:
Review the existing code and add error handling for file loading, masking, and calculations.
"""

# Reviewing existing code and adding error handling.

# Error handling for selecting years is already in the previous steps.
# Proceeding with file loading with error handling.

src1 = None
src2 = None
filename1 = tif_files.get(year1)
filename2 = tif_files.get(year2)

if filename1 and filename2:
    try:
        src1 = rasterio.open(filename1)
        print(f"Successfully opened {filename1}")
    except rasterio.errors.RasterioIOError as e:
        print(f"Error opening file {filename1}: {e}")
    except Exception as e:
        print(f"An unexpected error occurred while opening {filename1}: {e}")

    try:
        src2 = rasterio.open(filename2)
        print(f"Successfully opened {filename2}")
    except rasterio.errors.RasterioIOError as e:
        print(f"Error opening file {filename2}: {e}")
    except Exception as e:
        print(f"An unexpected error occurred while opening {filename2}: {e}")

# Proceeding with masking and calculation with error handling, only if files were opened successfully.
out_image1 = None
out_image2 = None
out_transform1 = None
out_transform2 = None
population_difference = None

if src1 and src2:
    try:
        out_image1, out_transform1 = mask(src1, [mapping(roi)], crop=True)
        print(f"Successfully masked {filename1}")

        # Handle nodata values for the first raster
        nodata1 = src1.nodata
        if nodata1 is not None:
            out_image1 = out_image1.astype(float)
            out_image1[out_image1 == nodata1] = 0  # Replace with 0


    except Exception as e:
        print(f"Error masking file {filename1}: {e}")
        out_image1 = None # Set to None if masking fails


    try:
        out_image2, out_transform2 = mask(src2, [mapping(roi)], crop=True)
        print(f"Successfully masked {filename2}")

        # Handle nodata values for the second raster
        nodata2 = src2.nodata
        if nodata2 is not None:
            out_image2 = out_image2.astype(float)
            out_image2[out_image2 == nodata2] = 0  # Replace with 0

    except Exception as e:
        print(f"Error masking file {filename2}: {e}")
        out_image2 = None # Set to None if masking fails


    # Proceed with calculation only if both images were masked successfully and have compatible shapes
    if out_image1 is not None and out_image2 is not None and out_image1.shape == out_image2.shape:
        try:
            # Determine which year is earlier and which is later
            if year1 < year2:
                earlier_year = year1
                later_year = year2
                earlier_image = out_image1
                later_image = out_image2
            else:
                earlier_year = year2
                later_year = year1
                earlier_image = out_image2
                later_image = out_image1

            # Subtract the population data of the earlier year from the later year
            population_difference = later_image - earlier_image
            print("Successfully calculated population difference.")

        except Exception as e:
            print(f"Error calculating population difference: {e}")
            population_difference = None # Set to None if calculation fails
    elif out_image1 is not None and out_image2 is not None and out_image1.shape != out_image2.shape:
        print(f"Error: Masked images have different shapes: {out_image1.shape} vs {out_image2.shape}. Cannot calculate difference.")
        population_difference = None
else:
    print("File loading failed, skipping masking and calculation.")

# Visualization step would follow here, and should also check if population_difference is not None